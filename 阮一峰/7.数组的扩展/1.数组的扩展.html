<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>数组的扩展</title>
    <script>
        window.onload=()=>{
//--------------------------------------------------------------
//扩展运算符(...)，将一个数组转换为用逗号分隔的参数序列。
            //如: (...[1,2,3,] === 1,2,3)
            // var arr = [1,2,3];
            // ...arr;  //1,2,3
//该运算符主要用于函数的调用:
            // const arr = [1,2];
            // function show(a,b){
            //     return a/b;
            // }
            // show(...arr); //0.5
//也可以和正常的函数结合使用
            // const number = [1,2];
            // function show2(a,b,c,d,e){
            //     return (a+b+c+d+e);
            // }
            // show2(0,...number,5,...[10]);   //18
//扩展运算符后面也可以放表达式
            // ...(true?[1,2,3]:[4,5,6]);  //1,2,3

//--------------------------------------------------------------
//代替函数的apply方法
            // fun.apply(null,arr); //ES5写法
            // fun(...arr); //ES6写法  //方便直观
    //例一: 通过push函数,将一个数组添加到另一个数组的尾部
    //ES5
            // const arr = [1,2,3];
            // const arr2 = [4,5,6];
            // Array.prototype.push.apply(arr,arr2);
            // arr;  //[1,2,3,4,5,6]
    //ES6
            // arr.push(...arr2);
            // arr;  //[1,2,3,4,5,6]
            
//--------------------------------------------------------------
//数组的克隆
    //不可用这个方法
        // const arr = [1,2];
        // const arr2 = arr;   
        // arr2[0] = 2;
        // arr;  //2,2 //修改arr2,arr也会改变,所以这种不是克隆。
    //ES5克隆数组,需要通过变通
        // const arr2 = arr.concat();
        // arr2[0] = 2;
        // console.log(arr,arr2); //[1,2],[2,2]//变通实现
    // ES6可以直接用扩展运算符(...)
        // const arr2 = [...arr];
        // arr2[0] = 2;
        // console.log(arr,arr2); //Array [1,2],Array [2,2]
//合并数组
        //ES5
            // const arr = [1,2];
            // const arr1 = [3,4];
            // const arr2 = [5,6];
            // arr.concat(arr1,arr2);
        //ES6
            // [...arr,...arr1,...arr2];

//--------------------------------------------------------------
//与解构赋值结合（只能放在变量的最后一位）
        //解构赋值和扩展运算符结合(...)
        // let [a,...arr] = [1,2,3,4,5];
        // a,arr;   //1,[2,3,4,5]
//--------------------------------------------------------------
//将字符串变成真正的数组
        [..."hello"]  //Array(5) [ "h", "e", "l", "l", "o" ]
        // 这样写还有一个重要的好处就是可以正确实别unicode编码
//--------------------------------------------------------------
//扩展运算符可以将类数组对象转换为真正的数组(Array.form或者arrayLike都可以)
        // var btns = document.querySelectorAll("button");
        // var btns = [...btns];
        // console.log(btns instanceof Array);  //true //btns变成了一个真正的数组

//--------------------------------------------------------------
//Array.form()该方法用于将类数组对象和可便利对象转为真正的数组
        // let arrayLike = {
        //     '0':'1',
        //     '1':'2',
        //     '2':'3',
        //     'length':3,
        // };
        // Array.from(arrayLike);  //[1,2,3] //转换成了真正的数组
        // 得出结论:只要有length属性的对象,就可以用词方法转为数组
        
//------//实际应用中常常用于将NodeList集合和arguments对象转换为数组
        //NodeList
        // var p = document.querySelectorAll('p');
        // Array.form(p).filter(...)

        // //arguments
        // function foo(){
        //     var args = Array.from(arguments);
        // }
//------该方法还接受第二个参数:作用类似于数组的map方法,用来对每个元素进行处理,
//      将处理后的值放入返回的数组
        Array.from([1,2,3],x=>x*x);  //[1,4,9]
        // 等同于
        Array.from([1,2,3]).map(x=>x*x); //[1,4,9]

//--------------------------------------------------------------
//Array.of()方法,用于将一组值,转换为数组
        Array.of(1,2,3);  //[1,2,3]
        Array.of('lo','ci','hua');  //["lo","ci","hua"]

//--------------------------------------------------------------
// 实例方法
//Array.prototype.copyWithin(target,start(可选),start(可选))
/*
            target:从该位置开始替换数据,如果是负数,表示倒数
            start:从该位置开始读取数据,默认为0,如果是负数,表示倒数
            end:到该位置前停止读取数据,默认为数组长度,如果是负数,表示倒数
*/
        [1,2,3,4,5].copyWithin(0,2);  //[3,4,5,4,5] //0开始替换,2开始读取
        [1,2,3,4,5].copyWithin(0,2,3);  //[3,2,3,4,5] //0开始替换,2开始读取,3结束读取

//--------------------------------------------------------------
//find()和findIndex()

/*find()方法,参数为一个回调函数,指定规则,所有成员一次传入函数,返回 第一个 符合
规则的成员.*/
    [1,2,3,4,5].find(x=>x>3);  //4 //返回第一个符合的

/*findIndex()方法,参数为一个回调函数,指定规则,所有成员一次传入函数,返回 第一个 
符合规则的成员的位置.*/
    [1,2,3,4,5].findIndex(x=>x>3); //3 //返回第一个符合的成员位置  

//--------------------------------------------------------------
//fill()方法,用于填充数组
//用该方法填充数组,会抹去其已有的元素.
    [1,2,3].fill(7);  //[7,7,7];
//fill()方法还可以指定第二第三个参数,第二个参数表示填充的起始位置,第三个参数表示结束位置.
    [1,2,3].fill(7,1,2); //[1,7,3];
//用于创建数组
    var arr = new Array(3).fill({name:"lonegr"});
    arr; // [ {…}, {…}, {…} ]

//--------------------------------------------------------------
// 数组实例的:entries(),keys(),values()
/*ES6提供三个新的方法,用于遍历数组,它们都返回一个遍历器对象(Iterator),可以用for..of循环进行遍历
唯一的区别就是,keys()是键名的遍历,values()是对键值的遍历,entries()是对键值对的遍历*/

//keys()
    for(let index of ["a","b","c"].keys()){
        console.log(index); //0,1,2
    }
//values()
    for(let item of ["a","b","c"].values()){
        console.log(item); //a,b,c
    }
//entries()
    for(let [index,item] of  ["a","b","c"].entries()){
        console.log(`#${index}:${item}`);  //#0:a ,#1:b ,#2:c
    }
//如果不使用for...of循环,可以使用遍历器对象的next方法,进行逐个遍历
    let entries = ["a","b","c"].entries();
    console.log(entries.next().value); //[0, 'a']
    console.log(entries.next().value); //[1, 'b']
    console.log(entries.next().value); //[2, 'c']

//--------------------------------------------------------------
// includes()方法:用于检查一个数组中是否包含某个成员,返回一个布尔值
    [1,2,3].includes(5); //false
    [1,2,3].includes(2); //true
/*该方法可以指定第二个参数,表示开始搜索的位置,如果为负数,则从倒数开始.如果负值大于数组
长度,则重置为0*/
    [1,2,3].includes(2,3); //false
    [1,2,3].includes(2,-5); //true //如果负值大于数组长度.则会重置为0
/*没有该方法前,我们使用indexOf()来判断,但是indexOf()方法有两个缺点
    1：不够语义化,它的含义是找到参数值的第一次出现的位置,还要去判断是否不等于-1
    2： 它内部使用严格等于运算符,这样会导致对NaN的误判。
*/

//--------------------------------------------------------------
//flat()和flatMap()方法
/*flat()方法,用于将一个嵌套数组'拉平',变为一个不嵌套的数组。
  - 但是默认只会'拉平'一层，(默认参数为1),可以指定参数,为Infinity(拉平多层)。
*/
    [1,2,[3,4]].flat(); //[ 1, 2, 3, 4 ] //默认为一层
    [1,[2,[3,4]]].flat(2); //[ 1, 2, 3, 4 ] //指定参数为两层
    [1, [2, [3]]].flat(Infinity); //[ 1, 2, 3 ] //拉平多层

//flatMap()方法是相当于给数组执行了Array.prototype.Map()方法,在执行flat()方法。
/*
    但是该方法默认只会展开一层,如果是两层以上嵌套函数，则还是会返回一个嵌套函数
    - 参数是一个回调函数,回调函数有三个形参:
    1. 数组当前成员
    2. 数组当前成员的位置
    3. 原数组
    - 也可以有第二个参数,用来绑定遍历函数里面的this
*/
    [1,2,[3,4],5].flatMap(x=>[[x*2]]);

//--------------------------------------------------------------
//ES6对数组空位的处理:全部转换为undefined
//ES5对数组空位的处理:
/*
    forEach(), filter(), reduce(), every() 和some()都会跳过空位。
    map()会跳过空位，但会保留这个值
    join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。
*/







        }
    </script>
</head>
<body>
    
</body>
</html>